<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Pasur</title>
    
    <link rel="icon" type="image/png" href="icon_2.PNG">
    <link rel="apple-touch-icon" href="icon_2.PNG">

    <style>
        :root {
            --felt-green: #2d5e2e;
            --card-width: 60px;
            --card-height: 84px;
            --card-radius: 6px;
            --highlight: #ffd700;
            --safe-top: env(safe-area-inset-top, 20px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--felt-green);
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            padding-top: calc(var(--safe-top) + 10px); 
            touch-action: none; /* Prevents browser scrolling/zooming to allow pure swipe detection */
        }

        /* --- Layout Containers --- */
        #game-board {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            position: relative;
        }

        .player-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 110px;
            padding: 0 10px;
        }

        /* --- Side Indicators (Turn & Surs) --- */
        .turn-indicator {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0.3;
            transition: opacity 0.3s;
        }
        
        .turn-indicator.active {
            opacity: 1;
        }

        .turn-dot {
            width: 15px;
            height: 15px;
            background-color: var(--highlight);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--highlight);
            animation: pulse 1.5s infinite;
        }

        .sur-area {
            width: 60px;
            text-align: right;
            font-size: 0.8rem;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }

        .sur-pill {
            background: var(--highlight);
            color: #333;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            margin-bottom: 2px;
        }

        /* --- Card Areas --- */
        .hand-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            height: 100%;
        }

        #opponent-hand .card {
            background: linear-gradient(135deg, #a83232 0%, #7d1e1e 100%);
            border: 2px solid #fff;
        }

        #table-area {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
            align-content: center;
            justify-content: center;
            padding: 10px;
            gap: 8px;
            position: relative;
        }

        /* --- Cards --- */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background-color: white;
            border-radius: var(--card-radius);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 4px;
            box-sizing: border-box;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            -webkit-tap-highlight-color: transparent;
        }

        .card.red { color: #d40000; }
        .card.black { color: #000; }

        .card-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        .card.selected {
            transform: translateY(-15px);
            box-shadow: 0 0 0 3px var(--highlight), 0 5px 15px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .card.target-selected {
            box-shadow: 0 0 0 3px #00e5ff;
        }

        /* --- Controls --- */
        #controls {
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom, 0px));
            position: relative;
        }

        .btn-wrapper {
            display: inline-block;
            position: relative;
        }

        button {
            background: var(--highlight);
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-weight: bold;
            color: #333;
            font-size: 1.1rem;
            box-shadow: 0 4px 0 #bfa200;
            cursor: pointer;
            transition: all 0.1s;
            min-width: 120px;
        }
        button:active {
            transform: translateY(3px);
            box-shadow: none;
        }
        button:disabled {
            background: #999;
            box-shadow: none;
            color: #555;
            cursor: default;
            opacity: 0.5;
        }

        /* --- Modals --- */
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            display: none;
            z-index: 100;
            width: 80%;
            max-width: 300px;
            border: 1px solid #555;
        }

        @keyframes pulse {
            0% { transform: scale(0.95); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(0.95); opacity: 0.7; }
        }

        /* Responsive */
        @media (min-width: 600px) {
            :root {
                --card-width: 80px;
                --card-height: 112px;
            }
        }
    </style>
</head>
<body>

<div id="game-board">
    <div class="player-row" style="margin-top: 10px;">
        <div class="turn-indicator" id="cpu-turn-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ffd700" stroke-width="2">
                <rect x="2" y="2" width="20" height="20" rx="5"></rect>
                <circle cx="12" cy="12" r="3"></circle>
                <line x1="12" y1="2" x2="12" y2="6"></line>
            </svg>
        </div>
        
        <div id="opponent-hand" class="hand-area"></div>
        
        <div class="sur-area">
            <div id="cpu-sur-container"></div>
        </div>
    </div>

    <div id="table-area"></div>

    <div class="player-row">
        <div class="turn-indicator" id="player-turn-icon">
             <div class="turn-dot"></div>
        </div>

        <div id="player-hand" class="hand-area"></div>

        <div class="sur-area">
            <div id="player-sur-container"></div>
        </div>
    </div>
</div>

<div id="controls">
    <div class="btn-wrapper" onclick="checkDisabledReason()">
        <button id="btn-action" onclick="handleActionButton()">Play</button>
    </div>
</div>

<div id="message-overlay">
    <h2 id="msg-title" style="margin-top:0">Round Over</h2>
    <div id="msg-body" style="margin: 20px 0; line-height: 1.5; color: #ccc;"></div>
    <button onclick="closeOverlay()">Next Round</button>
</div>

<script>
    const SUITS = ['♣', '♦', '♥', '♠'];
    const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    
    // State
    let deck = [];
    let table = [];
    let playerHand = [];
    let cpuHand = [];
    let playerPile = [];
    let cpuPile = [];
    let playerSurs = 0;
    let cpuSurs = 0;
    
    let isPlayerTurn = true;
    let lastRound = false; 
    let lastTaker = null; 

    // Selection
    let selectedHandIndex = -1;
    let selectedTableIndices = [];
    
    // Logic Debug
    let pickupPossibleForSelected = false;

    // --- Swipe Detection Variables ---
    let touchStartY = 0;
    let touchStartTime = 0;

    // --- Init ---
    function createDeck() {
        let d = [];
        for (let s of SUITS) {
            for (let r of RANKS) {
                let val = parseInt(r);
                if (r === 'A') val = 1;
                else if (r === 'J') val = 11;
                else if (r === 'Q') val = 12;
                else if (r === 'K') val = 13;
                else val = parseInt(r);
                
                d.push({
                    suit: s, rank: r, value: val,
                    id: Math.random().toString(36).substr(2, 9)
                });
            }
        }
        for (let i = d.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [d[i], d[j]] = [d[j], d[i]];
        }
        return d;
    }

    function initGame() {
        deck = createDeck();
        playerPile = [];
        cpuPile = [];
        playerSurs = 0;
        cpuSurs = 0;
        lastRound = false;
        lastTaker = null;
        
        let validTable = false;
        while (!validTable) {
            let hasJack = false;
            for(let i=0; i<4; i++) {
                if (deck[i].rank === 'J') hasJack = true;
            }
            if (hasJack) {
                 deck.sort(() => Math.random() - 0.5);
            } else {
                validTable = true;
            }
        }
        
        dealRound(true);
    }

    function dealRound(isFirst) {
        if (deck.length === 0) {
            calculateScore();
            return;
        }

        if (isFirst) {
            for (let i=0; i<4; i++) table.push(deck.pop());
        }
        
        for (let i=0; i<4; i++) playerHand.push(deck.pop());
        for (let i=0; i<4; i++) cpuHand.push(deck.pop());

        if (deck.length === 0) lastRound = true;

        updateUI();
        
        isPlayerTurn = true;
        setTurnIndicators();
        checkPossibleMoves();
    }

    function setTurnIndicators() {
        const pIcon = document.getElementById('player-turn-icon');
        const cIcon = document.getElementById('cpu-turn-icon');
        
        if (isPlayerTurn) {
            pIcon.classList.add('active');
            cIcon.classList.remove('active');
        } else {
            pIcon.classList.remove('active');
            cIcon.classList.add('active');
        }
    }

    // --- Core Logic ---
    function canCardPickUpAny(card, currentTable) {
        if (card.rank === 'K') return currentTable.some(c => c.rank === 'K');
        if (card.rank === 'Q') return currentTable.some(c => c.rank === 'Q');
        if (card.rank === 'J') return currentTable.some(c => c.rank === 'J' || c.value <= 10);
        
        if (card.value <= 10) {
            const target = 11 - card.value;
            const nums = currentTable.filter(c => c.value <= 10);
            const validNums = nums.filter(c => c.value <= target);
            return hasSubsetSum(validNums.map(c => c.value), target);
        }
        return false;
    }

    function hasSubsetSum(numbers, target) {
        if (target === 0) return true;
        if (numbers.length === 0) return false;
        const first = numbers[0];
        const rest = numbers.slice(1);
        if (first > target) return hasSubsetSum(rest, target);
        if (hasSubsetSum(rest, target - first)) return true;
        return hasSubsetSum(rest, target);
    }

    function validateMove(card, selectedTableCards, allTableCards) {
        if (selectedTableCards.length === 0) {
            if (canCardPickUpAny(card, allTableCards)) {
                return { isValid: false, reason: "Must Pick Up!" };
            }
            return { isValid: true, isPickup: false };
        }

        if (card.rank === 'K') {
            if (selectedTableCards.length === 1 && selectedTableCards[0].rank === 'K') return { isValid: true, isPickup: true };
            return { isValid: false };
        }
        if (card.rank === 'Q') {
            if (selectedTableCards.length === 1 && selectedTableCards[0].rank === 'Q') return { isValid: true, isPickup: true };
            return { isValid: false };
        }
        if (card.rank === 'J') {
            const validSubset = selectedTableCards.every(c => c.rank === 'J' || c.value <= 10);
            if (!validSubset) return { isValid: false };
            return { isValid: true, isPickup: true, special: 'JACK_SWEEP' };
        }
        if (card.value <= 10) {
            if (selectedTableCards.some(c => c.value > 10)) return { isValid: false };
            const sum = selectedTableCards.reduce((a, b) => a + b.value, 0);
            if (sum + card.value === 11) return { isValid: true, isPickup: true };
            return { isValid: false };
        }
        return { isValid: false };
    }

    // --- Interaction ---
    function handleActionButton() {
        const btn = document.getElementById('btn-action');
        if (btn.disabled || !isPlayerTurn) return;
        
        const card = playerHand[selectedHandIndex];
        let tableSubset = selectedTableIndices.map(i => table[i]);

        let v = validateMove(card, tableSubset, table);
        if (!v.isValid) return;

        playerHand.splice(selectedHandIndex, 1);

        if (v.isPickup) {
            if (v.special === 'JACK_SWEEP') {
                const toTake = [];
                const toLeave = [];
                table.forEach(c => {
                    if (c.rank === 'J' || c.value <= 10) toTake.push(c);
                    else toLeave.push(c);
                });
                table = toLeave;
                playerPile.push(card, ...toTake);
            } else {
                selectedTableIndices.sort((a,b) => b-a);
                selectedTableIndices.forEach(idx => {
                    playerPile.push(table[idx]);
                    table.splice(idx, 1);
                });
                playerPile.push(card);
            }
            lastTaker = 'player';
            checkSur(true, card); 
        } else {
            table.push(card);
        }

        selectedHandIndex = -1;
        selectedTableIndices = [];
        updateUI();
        
        checkRoundOrTurnEnd();
    }

    function checkDisabledReason() {
        const btn = document.getElementById('btn-action');
        if (!btn.disabled) return;
        if (!isPlayerTurn) return;

        if (selectedHandIndex === -1) {
            showToast("Select a card");
        } else if (pickupPossibleForSelected && selectedTableIndices.length === 0) {
            showToast("Must Pick Up!");
        } else {
            if (selectedTableIndices.length > 0) showToast("Invalid Match");
        }
    }

    function checkSur(isPlayer, playedCard) {
        if (table.length === 0 && !lastRound) {
            if (playedCard.rank === 'J') {
                showToast("Jack Clear (No Sur)");
            } else {
                if (isPlayer) playerSurs++; else cpuSurs++;
                showToast("SUR!");
            }
        }
    }

    function cpuTurn() {
        const move = calculateCPUMove();
        
        const cardIndex = cpuHand.indexOf(move.card);
        cpuHand.splice(cardIndex, 1);
        
        if (move.isPickup) {
            const newTable = [];
            const taken = [];
            table.forEach(t => {
                if (move.targets.includes(t)) taken.push(t);
                else newTable.push(t);
            });
            table = newTable;
            cpuPile.push(move.card, ...taken);
            lastTaker = 'cpu';
            checkSur(false, move.card);
        } else {
            table.push(move.card);
        }

        updateUI();
        checkRoundOrTurnEnd();
    }

    function checkRoundOrTurnEnd() {
        if (playerHand.length === 0 && cpuHand.length === 0) {
            if (deck.length > 0) {
                setTimeout(() => dealRound(false), 1000);
            } else {
                if (table.length > 0) {
                    if (lastTaker === 'player') playerPile.push(...table);
                    else cpuPile.push(...table);
                    table = [];
                    updateUI();
                }
                calculateScore();
            }
        } else {
            isPlayerTurn = !isPlayerTurn;
            setTurnIndicators();
            if (!isPlayerTurn) {
                setTimeout(cpuTurn, 1000 + Math.random()*500);
            } else {
                checkPossibleMoves();
            }
        }
    }

    function checkPossibleMoves() {
        const btn = document.getElementById('btn-action');
        btn.disabled = true;
        btn.textContent = "Play";
        pickupPossibleForSelected = false;
        
        if (selectedHandIndex === -1) return;

        const card = playerHand[selectedHandIndex];
        const tableSubset = selectedTableIndices.map(i => table[i]);
        
        pickupPossibleForSelected = canCardPickUpAny(card, table);

        const validation = validateMove(card, tableSubset, table);
        
        if (validation.isValid) {
            btn.disabled = false;
            btn.textContent = validation.isPickup ? "Pick Up" : "Discard";
        }
    }

    function calculateCPUMove() {
        let possibleMoves = [];

        for (let card of cpuHand) {
            if (card.rank === 'J') {
                const targets = table.filter(c => c.rank === 'J' || c.value <= 10);
                if (targets.length > 0) {
                    possibleMoves.push({ card: card, isPickup: true, targets: targets, score: 0 });
                } else {
                     possibleMoves.push({ card: card, isPickup: false, score: -5 });
                }
            } else if (card.rank === 'Q' || card.rank === 'K') {
                const match = table.find(c => c.rank === card.rank);
                if (match) {
                    possibleMoves.push({ card: card, isPickup: true, targets: [match], score: 0 });
                } else {
                    possibleMoves.push({ card: card, isPickup: false, score: 0 });
                }
            } else {
                const target = 11 - card.value;
                const nums = table.filter(c => c.value <= 10);
                const subsets = findSubsets(nums, target);
                if (subsets.length > 0) {
                    subsets.forEach(sub => {
                        possibleMoves.push({ card: card, isPickup: true, targets: sub, score: 0 });
                    });
                } else {
                    possibleMoves.push({ card: card, isPickup: false, score: 0 });
                }
            }
        }

        possibleMoves.forEach(m => {
            if (m.isPickup) {
                m.score += 10;
                m.score += m.targets.length * 2;
                [m.card, ...m.targets].forEach(c => {
                    if (c.suit === '♣') m.score += 1;
                    if (c.rank === 'A') m.score += 3;
                    if (c.rank === 'J') m.score += 3;
                    if (c.rank === '10' && c.suit === '♦') m.score += 10;
                    if (c.rank === '2' && c.suit === '♣') m.score += 5;
                });
                if (table.length === m.targets.length && !lastRound && m.card.rank !== 'J') {
                    m.score += 50; 
                }
            } else {
                if (m.card.rank === 'A' || m.card.rank === 'J' || m.card.rank === '10' || m.card.rank === '2') {
                    m.score -= 5; 
                }
            }
        });

        const cardsWithPickup = new Set(possibleMoves.filter(m => m.isPickup).map(m => m.card));
        possibleMoves = possibleMoves.filter(m => {
            if (!m.isPickup && cardsWithPickup.has(m.card)) return false;
            return true;
        });

        possibleMoves.sort((a,b) => b.score - a.score);
        return possibleMoves[0];
    }

    function findSubsets(arr, target) {
        let res = [];
        function backtrack(index, current, currentSum) {
            if (currentSum === target) {
                res.push([...current]);
                return;
            }
            if (currentSum > target || index >= arr.length) return;
            current.push(arr[index]);
            backtrack(index + 1, current, currentSum + arr[index].value);
            current.pop();
            backtrack(index + 1, current, currentSum);
        }
        backtrack(0, [], 0);
        return res;
    }

    function calculateScore() {
        let pScore = 0;
        let cScore = 0;

        const pClubs = playerPile.filter(c => c.suit === '♣').length;
        const cClubs = cpuPile.filter(c => c.suit === '♣').length;
        
        if (pClubs > cClubs) pScore += 7;
        else if (cClubs > pClubs) cScore += 7;

        [playerPile, cpuPile].forEach((pile, idx) => {
            let score = 0;
            pile.forEach(c => {
                if (c.rank === 'A') score += 1;
                if (c.rank === 'J') score += 1;
                if (c.rank === '10' && c.suit === '♦') score += 3;
                if (c.rank === '2' && c.suit === '♣') score += 2;
            });
            if (idx === 0) pScore += score; else cScore += score;
        });

        pScore += (playerSurs * 5);
        cScore += (cpuSurs * 5);

        const body = document.getElementById('msg-body');
        body.innerHTML = `
            <div style="font-size:1.5rem; color:white; margin-bottom:10px;">${pScore} - ${cScore}</div>
            <div style="font-size:0.9rem">
            YOU: ${pClubs} Clubs, ${playerSurs} Surs<br>
            CPU: ${cClubs} Clubs, ${cpuSurs} Surs
            </div>
        `;
        document.getElementById('message-overlay').style.display = 'block';
    }

    function closeOverlay() {
        document.getElementById('message-overlay').style.display = 'none';
        initGame();
    }
    
    function showToast(msg) {
        const existing = document.getElementById('toast-msg');
        if (existing) existing.remove();

        const d = document.createElement('div');
        d.id = 'toast-msg';
        d.textContent = msg;
        d.style.position = 'absolute';
        d.style.top = '50%';
        d.style.left = '50%';
        d.style.transform = 'translate(-50%, -50%)';
        d.style.background = 'rgba(255, 215, 0, 0.95)';
        d.style.color = '#000';
        d.style.padding = '12px 25px';
        d.style.borderRadius = '30px';
        d.style.fontWeight = 'bold';
        d.style.zIndex = 200;
        d.style.pointerEvents = 'none';
        d.style.whiteSpace = 'nowrap';
        d.style.boxShadow = '0 5px 15px rgba(0,0,0,0.5)';
        d.style.animation = 'fadeout 1.5s forwards';
        
        document.body.appendChild(d);
        setTimeout(() => { if(d.parentNode) d.remove(); }, 1500);
    }

    function updateUI() {
        const pSurCont = document.getElementById('player-sur-container');
        const cSurCont = document.getElementById('cpu-sur-container');
        
        pSurCont.innerHTML = '';
        for(let i=0; i<playerSurs; i++) {
            const sp = document.createElement('div');
            sp.className = 'sur-pill';
            sp.textContent = 'SUR';
            pSurCont.appendChild(sp);
        }

        cSurCont.innerHTML = '';
        for(let i=0; i<cpuSurs; i++) {
            const sp = document.createElement('div');
            sp.className = 'sur-pill';
            sp.textContent = 'SUR';
            cSurCont.appendChild(sp);
        }

        const tableDiv = document.getElementById('table-area');
        tableDiv.innerHTML = '';
        table.forEach((card, idx) => {
            const el = createCardEl(card);
            el.onclick = () => toggleTableSelection(idx);
            if (selectedTableIndices.includes(idx)) el.classList.add('target-selected');
            tableDiv.appendChild(el);
        });

        const pHandDiv = document.getElementById('player-hand');
        pHandDiv.innerHTML = '';
        playerHand.forEach((card, idx) => {
            const el = createCardEl(card);
            el.onclick = () => selectHandCard(idx);
            if (idx === selectedHandIndex) el.classList.add('selected');
            pHandDiv.appendChild(el);
        });

        const cHandDiv = document.getElementById('opponent-hand');
        cHandDiv.innerHTML = '';
        cpuHand.forEach(() => {
            const el = document.createElement('div');
            el.className = 'card';
            el.style.background = 'linear-gradient(135deg, #602a2a 0%, #3d0d0d 100%)';
            el.style.border = '2px solid white';
            cHandDiv.appendChild(el);
        });
        
        checkPossibleMoves();
    }

    function createCardEl(card) {
        const el = document.createElement('div');
        el.className = `card ${['♥','♦'].includes(card.suit) ? 'red' : 'black'}`;
        el.innerHTML = `
            <div style="font-size:14px; text-align:left;">${card.rank}</div>
            <div class="card-center">${card.suit}</div>
            <div style="font-size:14px; text-align:right; transform: rotate(180deg);">${card.rank}</div>
        `;
        return el;
    }

    function selectHandCard(idx) {
        if (!isPlayerTurn) return;
        if (selectedHandIndex === idx) selectedHandIndex = -1; 
        else selectedHandIndex = idx;
        selectedTableIndices = []; 
        updateUI();
    }

    function toggleTableSelection(idx) {
        if (!isPlayerTurn) return;
        if (selectedHandIndex === -1) {
            showToast("Select a card first");
            return; 
        }
        const pos = selectedTableIndices.indexOf(idx);
        if (pos >= 0) selectedTableIndices.splice(pos, 1);
        else selectedTableIndices.push(idx);
        updateUI();
    }

    // --- Gesture Listeners ---
    document.addEventListener('touchstart', e => {
        touchStartY = e.changedTouches[0].screenY;
        touchStartTime = new Date().getTime();
    }, {passive: false});

    document.addEventListener('touchend', e => {
        const touchEndY = e.changedTouches[0].screenY;
        const endTime = new Date().getTime();
        
        const distance = touchStartY - touchEndY; // Positive = UP
        const duration = endTime - touchStartTime;

        // Threshold: >150px dist, <400ms duration
        if (distance > 150 && duration < 400) {
            showToast("Resetting Game...");
            setTimeout(initGame, 500);
        }
    }, {passive: false});

    const styleSheet = document.createElement("style");
    styleSheet.innerText = `
        @keyframes fadeout {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -60%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -100%); }
        }
    `;
    document.head.appendChild(styleSheet);

    initGame();
</script>
</body>
</html>
