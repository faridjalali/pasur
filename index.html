<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Pasur</title>
    
    <link rel="icon" type="image/png" href="icon_2.PNG">
    <link rel="apple-touch-icon" href="icon_2.PNG">

    <style>
        :root {
            --felt-green: #2d5e2e;
            --card-width: 60px;
            --card-height: 84px;
            --card-radius: 6px;
            --highlight: #ffd700;
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--felt-green);
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            padding-top: calc(var(--safe-top) + 10px); 
            touch-action: none; 
        }

        #game-board {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 20px;
            padding: 10px;
            position: relative;
        }

        /* --- Player Rows --- */
        .player-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 100px; 
            padding: 0 10px;
            position: relative;
            z-index: 2;
        }

        /* --- STACK ANCHORS (The visible stacking containers) --- */
        .stack-anchor {
            position: absolute;
            right: 10px; /* Locked to the right side */
            top: 50%;
            transform: translateY(-50%);
            width: var(--card-width);
            height: var(--card-height); /* Base height of one card */
            z-index: 999; /* Highest priority */
            pointer-events: none; /* Let clicks pass through */
            /* Ensure no overflow clipping so the stack can hang down */
            overflow: visible; 
        }

        /* Used by JS to create the cards inside the anchor */
        .stacked-card {
            position: absolute !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            margin: 0 !important;
            background-color: white;
            border-radius: var(--card-radius);
            border: 1px solid #999;
            box-shadow: 0 -1px 4px rgba(0,0,0,0.5); /* Shadow showing separation */
            transform-origin: top center;
        }

        /* --- Table Area --- */
        #table-area {
            flex: none; 
            height: 25vh; 
            min-height: 180px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            display: flex;
            flex-wrap: wrap;
            align-content: center;
            justify-content: center;
            padding: 10px;
            gap: 8px;
            position: relative; 
            z-index: 1;
        }

        /* --- Deck Counter --- */
        #deck-counter-pill {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
            letter-spacing: 0.5px;
            text-transform: uppercase;
            z-index: 5;
            pointer-events: none;
        }

        .hand-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            height: 100%;
        }

        /* --- Turn Indicator --- */
        .turn-indicator {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0.3;
            transition: opacity 0.3s;
        }
        
        .turn-indicator.active {
            opacity: 1;
        }

        .turn-dot {
            width: 15px;
            height: 15px;
            background-color: var(--highlight);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--highlight);
            animation: pulse 1.5s infinite;
        }

        /* --- Sur Area (Right Side) --- */
        .sur-area {
            width: 60px;
            text-align: right;
            font-size: 0.8rem;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
            transition: opacity 0.2s;
        }
        
        /* When stack is showing, hide the Surs to avoid overlap mess */
        .sur-area.hidden {
            opacity: 0;
        }

        .sur-pill {
            background: var(--highlight);
            color: #333;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            margin-bottom: 2px;
        }

        /* --- Cards --- */
        #opponent-hand .card {
            background: linear-gradient(135deg, #a83232 0%, #7d1e1e 100%);
            border: 2px solid #fff;
        }

        .card {
            width: var(--card-width);
            height: var(--card-height);
            background-color: white;
            border-radius: var(--card-radius);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 4px;
            box-sizing: border-box;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            -webkit-tap-highlight-color: transparent;
        }

        .card.red { color: #d40000; }
        .card.black { color: #000; }

        .card-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        .card.selected {
            transform: translateY(-15px);
            box-shadow: 0 0 0 3px var(--highlight), 0 5px 15px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .card.target-selected {
            box-shadow: 0 0 0 3px #00e5ff;
        }

        /* --- Controls --- */
        #controls {
            height: 100px; 
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 15px;
            padding-bottom: calc(40px + var(--safe-bottom));
            flex-shrink: 0;
        }

        .btn-wrapper {
            display: inline-block;
            position: relative;
        }

        button {
            background: var(--highlight);
            border: none;
            padding: 14px 40px;
            border-radius: 30px;
            font-weight: bold;
            color: #333;
            font-size: 1.2rem;
            box-shadow: 0 5px 0 #bfa200;
            cursor: pointer;
            transition: all 0.1s;
            min-width: 140px;
        }
        button:active {
            transform: translateY(3px);
            box-shadow: none;
        }
        button:disabled {
            background: #999;
            box-shadow: none;
            color: #555;
            cursor: default;
            opacity: 0.5;
        }

        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            display: none;
            z-index: 100;
            width: 80%;
            max-width: 300px;
            border: 1px solid #555;
        }

        @keyframes pulse {
            0% { transform: scale(0.95); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(0.95); opacity: 0.7; }
        }

        @media (min-width: 600px) {
            :root {
                --card-width: 80px;
                --card-height: 112px;
            }
        }
    </style>
</head>
<body>

<div id="game-board">
    <div class="player-row">
        <div class="turn-indicator" id="cpu-turn-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ffd700" stroke-width="2">
                <rect x="2" y="2" width="20" height="20" rx="5"></rect>
                <circle cx="12" cy="12" r="3"></circle>
                <line x1="12" y1="2" x2="12" y2="6"></line>
            </svg>
        </div>
        
        <div id="opponent-hand" class="hand-area"></div>
        
        <div id="cpu-stack-anchor" class="stack-anchor"></div>

        <div class="sur-area" id="cpu-sur-area">
            <div id="cpu-sur-container"></div>
        </div>
    </div>

    <div id="table-area">
        <div id="deck-counter-pill">Deck: 52</div>
    </div>

    <div class="player-row">
        <div class="turn-indicator" id="player-turn-icon">
             <div class="turn-dot"></div>
        </div>

        <div id="player-hand" class="hand-area"></div>
        
        <div id="player-stack-anchor" class="stack-anchor"></div>

        <div class="sur-area" id="player-sur-area">
            <div id="player-sur-container"></div>
        </div>
    </div>
</div>

<div id="controls">
    <div class="btn-wrapper" onclick="checkDisabledReason()">
        <button id="btn-action" onclick="handleActionButton()">Play</button>
    </div>
</div>

<div id="message-overlay">
    <h2 id="msg-title" style="margin-top:0">Round Over</h2>
    <div id="msg-body" style="margin: 20px 0; line-height: 1.5; color: #ccc;"></div>
    <button onclick="closeOverlay()">Next Round</button>
</div>

<script>
    const SUITS = ['♣', '♦', '♥', '♠'];
    const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    
    // State
    let deck = [];
    let table = [];
    let playerHand = [];
    let cpuHand = [];
    let playerPile = [];
    let cpuPile = [];
    let playerSurs = 0;
    let cpuSurs = 0;
    
    let isPlayerTurn = true;
    let lastRound = false; 
    let lastTaker = null; 
    let isPaused = false;

    // Selection
    let selectedHandIndex = -1;
    let selectedTableIndices = [];
    let pickupPossibleForSelected = false;

    // --- Swipe Variables ---
    let touchStartY = 0;
    let touchStartTime = 0;

    // --- Init ---
    function createDeck() {
        let d = [];
        for (let s of SUITS) {
            for (let r of RANKS) {
                let val = parseInt(r);
                if (r === 'A') val = 1;
                else if (r === 'J') val = 11;
                else if (r === 'Q') val = 12;
                else if (r === 'K') val = 13;
                else val = parseInt(r);
                
                d.push({
                    suit: s, rank: r, value: val,
                    id: Math.random().toString(36).substr(2, 9)
                });
            }
        }
        for (let i = d.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [d[i], d[j]] = [d[j], d[i]];
        }
        return d;
    }

    function initGame() {
        deck = createDeck();
        playerPile = [];
        cpuPile = [];
        playerSurs = 0;
        cpuSurs = 0;
        lastRound = false;
        lastTaker = null;
        isPaused = false;
        
        let validTable = false;
        while (!validTable) {
            let hasJack = false;
            for(let i=0; i<4; i++) {
                if (deck[i].rank === 'J') hasJack = true;
            }
            if (hasJack) {
                 deck.sort(() => Math.random() - 0.5);
            } else {
                validTable = true;
            }
        }
        
        dealRound(true);
    }

    function dealRound(isFirst) {
        if (deck.length === 0) {
            calculateScore();
            return;
        }

        if (isFirst) {
            for (let i=0; i<4; i++) table.push(deck.pop());
        }
        
        for (let i=0; i<4; i++) playerHand.push(deck.pop());
        for (let i=0; i<4; i++) cpuHand.push(deck.pop());

        if (deck.length === 0) lastRound = true;

        updateUI();
        
        isPlayerTurn = true;
        setTurnIndicators();
        checkPossibleMoves();
    }

    function setTurnIndicators() {
        const pIcon = document.getElementById('player-turn-icon');
        const cIcon = document.getElementById('cpu-turn-icon');
        
        if (isPlayerTurn) {
            pIcon.classList.add('active');
            cIcon.classList.remove('active');
        } else {
            pIcon.classList.remove('active');
            cIcon.classList.add('active');
        }
    }

    // --- Core Logic ---
    function canCardPickUpAny(card, currentTable) {
        if (card.rank === 'J') return currentTable.length > 0;
        if (card.rank === 'K') return currentTable.some(c => c.rank === 'K');
        if (card.rank === 'Q') return currentTable.some(c => c.rank === 'Q');
        
        if (card.value <= 10) {
            const target = 11 - card.value;
            const nums = currentTable.filter(c => c.value <= 10);
            const validNums = nums.filter(c => c.value <= target);
            return hasSubsetSum(validNums.map(c => c.value), target);
        }
        return false;
    }

    function hasSubsetSum(numbers, target) {
        if (target === 0) return true;
        if (numbers.length === 0) return false;
        const first = numbers[0];
        const rest = numbers.slice(1);
        if (first > target) return hasSubsetSum(rest, target);
        if (hasSubsetSum(rest, target - first)) return true;
        return hasSubsetSum(rest, target);
    }

    function validateMove(card, selectedTableCards, allTableCards) {
        if (card.rank === 'J') {
            if (allTableCards.length > 0) {
                return { isValid: true, isPickup: true, special: 'JACK_SWEEP' };
            } else {
                return { isValid: true, isPickup: false };
            }
        }

        if (selectedTableCards.length === 0) {
            if (canCardPickUpAny(card, allTableCards)) {
                return { isValid: false, reason: "Must Pick Up!" };
            }
            return { isValid: true, isPickup: false };
        }

        if (card.rank === 'K') {
            if (selectedTableCards.length === 1 && selectedTableCards[0].rank === 'K') return { isValid: true, isPickup: true };
            return { isValid: false };
        }
        if (card.rank === 'Q') {
            if (selectedTableCards.length === 1 && selectedTableCards[0].rank === 'Q') return { isValid: true, isPickup: true };
            return { isValid: false };
        }
        
        if (card.value <= 10) {
            if (selectedTableCards.some(c => c.value > 10)) return { isValid: false };
            const sum = selectedTableCards.reduce((a, b) => a + b.value, 0);
            if (sum + card.value === 11) return { isValid: true, isPickup: true };
            return { isValid: false };
        }
        return { isValid: false };
    }

    // --- UI/Animation ---
    function showCaptureAnim(cards, anchorId) {
        return new Promise(resolve => {
            const container = document.getElementById(anchorId);
            const surId = anchorId === 'cpu-stack-anchor' ? 'cpu-sur-area' : 'player-sur-area';
            
            // Hide Sur area temporarily so it doesn't overlap
            document.getElementById(surId).classList.add('hidden');
            
            container.innerHTML = ''; // Clear previous

            // Offset per card. 15px is enough to see rank/suit index
            const OFFSET = 15; 
            
            // Re-center logic: We want the middle of the stack to be at top:50% of the anchor
            // Anchor is fixed height (84px). Stack height is (N-1)*15 + 84.
            // We shift the first card up so the stack appears centered.
            const totalStackHeight = ((cards.length - 1) * OFFSET) + 84;
            const shiftUp = (totalStackHeight - 84) / 2;

            cards.forEach((card, i) => {
                const el = createCardEl(card);
                el.classList.add('stacked-card');
                
                // Position logic:
                // 1. Shift up to center the whole stack
                // 2. Shift down based on index (i * OFFSET)
                const topPos = -shiftUp + (i * OFFSET);
                
                el.style.top = topPos + 'px'; 
                
                // Z-index: i + 10. Higher index = sits ON TOP visually
                // covering the body of the card below it.
                el.style.zIndex = 10 + i; 
                
                container.appendChild(el);
            });

            isPaused = true;
            updateUI(); 

            setTimeout(() => {
                container.innerHTML = ''; // Wipe stack
                document.getElementById(surId).classList.remove('hidden'); // Show Surs
                isPaused = false;
                resolve();
            }, 1500);
        });
    }

    // --- Interaction ---
    async function handleActionButton() {
        const btn = document.getElementById('btn-action');
        if (btn.disabled || !isPlayerTurn || isPaused) return;
        
        const card = playerHand[selectedHandIndex];
        let tableSubset = selectedTableIndices.map(i => table[i]);

        let v = validateMove(card, tableSubset, table);
        if (!v.isValid) return;

        playerHand.splice(selectedHandIndex, 1);
        let captured = [];

        if (v.isPickup) {
            if (v.special === 'JACK_SWEEP') {
                captured = [card, ...table];
                playerPile.push(...captured);
                table = [];
            } else {
                selectedTableIndices.sort((a,b) => b-a);
                selectedTableIndices.forEach(idx => {
                    captured.push(table[idx]);
                    table.splice(idx, 1);
                });
                captured.push(card);
                playerPile.push(...captured);
            }
            lastTaker = 'player';
            
            selectedHandIndex = -1;
            selectedTableIndices = [];
            updateUI(); 
            
            checkSur(true, card); 
            // Trigger Player Stack
            await showCaptureAnim(captured, 'player-stack-anchor'); 
            
        } else {
            table.push(card);
            selectedHandIndex = -1;
            selectedTableIndices = [];
            updateUI();
        }

        checkRoundOrTurnEnd();
    }

    function checkDisabledReason() {
        const btn = document.getElementById('btn-action');
        if (!btn.disabled) return;
        if (!isPlayerTurn || isPaused) return;

        if (selectedHandIndex === -1) {
            showToast("Select a card");
        } else if (pickupPossibleForSelected && selectedTableIndices.length === 0) {
            const card = playerHand[selectedHandIndex];
            if (card.rank === 'J') return;
            showToast("Must Pick Up!");
        } else {
            if (selectedTableIndices.length > 0) showToast("Invalid Match");
        }
    }

    function checkSur(isPlayer, playedCard) {
        if (table.length === 0 && !lastRound) {
            if (playedCard.rank === 'J') {
                showToast("Jack Clear");
            } else {
                if (isPlayer) playerSurs++; else cpuSurs++;
                showToast("SUR!");
            }
        }
    }

    async function cpuTurn() {
        if (isPaused) return;
        const move = calculateCPUMove();
        
        const cardIndex = cpuHand.indexOf(move.card);
        cpuHand.splice(cardIndex, 1);
        
        let captured = [];

        if (move.isPickup) {
            const newTable = [];
            table.forEach(t => {
                if (move.targets.includes(t)) captured.push(t);
                else newTable.push(t);
            });
            table = newTable;
            captured.push(move.card);
            cpuPile.push(...captured);
            lastTaker = 'cpu';

            updateUI();
            checkSur(false, move.card);
            // Trigger CPU Stack
            await showCaptureAnim(captured, 'cpu-stack-anchor');
            
        } else {
            table.push(move.card);
            updateUI();
        }

        checkRoundOrTurnEnd();
    }

    function checkRoundOrTurnEnd() {
        if (playerHand.length === 0 && cpuHand.length === 0) {
            if (deck.length > 0) {
                setTimeout(() => dealRound(false), 500);
            } else {
                if (table.length > 0) {
                    if (lastTaker === 'player') playerPile.push(...table);
                    else cpuPile.push(...table);
                    table = [];
                    updateUI();
                }
                calculateScore();
            }
        } else {
            isPlayerTurn = !isPlayerTurn;
            setTurnIndicators();
            if (!isPlayerTurn) {
                setTimeout(cpuTurn, 1000 + Math.random()*500);
            } else {
                checkPossibleMoves();
            }
        }
    }

    function checkPossibleMoves() {
        const btn = document.getElementById('btn-action');
        btn.disabled = true;
        btn.textContent = "Play";
        pickupPossibleForSelected = false;
        
        if (isPaused || !isPlayerTurn) return; 
        if (selectedHandIndex === -1) return;

        const card = playerHand[selectedHandIndex];
        const tableSubset = selectedTableIndices.map(i => table[i]);
        
        pickupPossibleForSelected = canCardPickUpAny(card, table);

        const validation = validateMove(card, tableSubset, table);
        
        if (validation.isValid) {
            btn.disabled = false;
            btn.textContent = validation.isPickup ? "Pick Up" : "Discard";
        }
    }

    function calculateCPUMove() {
        let possibleMoves = [];

        for (let card of cpuHand) {
            if (card.rank === 'J') {
                if (table.length > 0) {
                    possibleMoves.push({ card: card, isPickup: true, targets: [...table], score: 0 });
                } else {
                     possibleMoves.push({ card: card, isPickup: false, score: -5 });
                }
            } else if (card.rank === 'Q' || card.rank === 'K') {
                const match = table.find(c => c.rank === card.rank);
                if (match) {
                    possibleMoves.push({ card: card, isPickup: true, targets: [match], score: 0 });
                } else {
                    possibleMoves.push({ card: card, isPickup: false, score: 0 });
                }
            } else {
                const target = 11 - card.value;
                const nums = table.filter(c => c.value <= 10);
                const subsets = findSubsets(nums, target);
                if (subsets.length > 0) {
                    subsets.forEach(sub => {
                        possibleMoves.push({ card: card, isPickup: true, targets: sub, score: 0 });
                    });
                } else {
                    possibleMoves.push({ card: card, isPickup: false, score: 0 });
                }
            }
        }

        possibleMoves.forEach(m => {
            if (m.isPickup) {
                m.score += 10;
                m.score += m.targets.length * 2;
                [m.card, ...m.targets].forEach(c => {
                    if (c.suit === '♣') m.score += 1;
                    if (c.rank === 'A') m.score += 3;
                    if (c.rank === 'J') m.score += 3;
                    if (c.rank === '10' && c.suit === '♦') m.score += 10;
                    if (c.rank === '2' && c.suit === '♣') m.score += 5;
                });
                if (table.length === m.targets.length && !lastRound && m.card.rank !== 'J') {
                    m.score += 50; 
                }
            } else {
                if (m.card.rank === 'A' || m.card.rank === 'J' || m.card.rank === '10' || m.card.rank === '2') {
                    m.score -= 5; 
                }
            }
        });

        const cardsWithPickup = new Set(possibleMoves.filter(m => m.isPickup).map(m => m.card));
        possibleMoves = possibleMoves.filter(m => {
            if (!m.isPickup && cardsWithPickup.has(m.card)) return false;
            return true;
        });

        possibleMoves.sort((a,b) => b.score - a.score);
        return possibleMoves[0];
    }

    function findSubsets(arr, target) {
        let res = [];
        function backtrack(index, current, currentSum) {
            if (currentSum === target) {
                res.push([...current]);
                return;
            }
            if (currentSum > target || index >= arr.length) return;
            current.push(arr[index]);
            backtrack(index + 1, current, currentSum + arr[index].value);
            current.pop();
            backtrack(index + 1, current, currentSum);
        }
        backtrack(0, [], 0);
        return res;
    }

    function calculateScore() {
        let pScore = 0;
        let cScore = 0;

        const pClubs = playerPile.filter(c => c.suit === '♣').length;
        const cClubs = cpuPile.filter(c => c.suit === '♣').length;
        
        let pPoints = 0;
        let cPoints = 0;

        if (pClubs > cClubs) pPoints += 7;
        else if (cClubs > pClubs) cPoints += 7;

        [playerPile, cpuPile].forEach((pile, idx) => {
            let pts = 0;
            pile.forEach(c => {
                if (c.rank === 'A') pts += 1;
                if (c.rank === 'J') pts += 1;
                if (c.rank === '10' && c.suit === '♦') pts += 3;
                if (c.rank === '2' && c.suit === '♣') pts += 2;
            });
            if (idx === 0) pPoints += pts; else cPoints += pts;
        });

        pPoints += (playerSurs * 5);
        cPoints += (cpuSurs * 5);

        const body = document.getElementById('msg-body');
        body.innerHTML = `
            <div style="font-size:1.5rem; color:white; margin-bottom:10px;">${pPoints} - ${cPoints}</div>
            <div style="font-size:0.9rem; text-align:left; display:inline-block; line-height:1.6;">
            <strong>Your Stats:</strong><br>
            Clubs: ${pClubs} <br>
            Surs: ${playerSurs} (x5)<br>
            Points (A, J, 10♦, 2♣): ${playerPile.reduce((acc, c) => {
                if(c.rank=='A'||c.rank=='J') return acc+1;
                if(c.rank=='10'&&c.suit=='♦') return acc+3;
                if(c.rank=='2'&&c.suit=='♣') return acc+2;
                return acc;
            }, 0)}
            <br><br>
            <strong>CPU Stats:</strong><br>
            Clubs: ${cClubs} <br>
            Surs: ${cpuSurs} (x5)
            </div>
        `;
        document.getElementById('message-overlay').style.display = 'block';
    }

    function closeOverlay() {
        document.getElementById('message-overlay').style.display = 'none';
        initGame();
    }
    
    function showToast(msg) {
        const existing = document.getElementById('toast-msg');
        if (existing) existing.remove();

        const d = document.createElement('div');
        d.id = 'toast-msg';
        d.textContent = msg;
        d.style.position = 'absolute';
        d.style.top = '50%';
        d.style.left = '50%';
        d.style.transform = 'translate(-50%, -50%)';
        d.style.background = 'rgba(255, 215, 0, 0.95)';
        d.style.color = '#000';
        d.style.padding = '12px 25px';
        d.style.borderRadius = '30px';
        d.style.fontWeight = 'bold';
        d.style.zIndex = 200;
        d.style.pointerEvents = 'none';
        d.style.whiteSpace = 'nowrap';
        d.style.boxShadow = '0 5px 15px rgba(0,0,0,0.5)';
        d.style.animation = 'fadeout 1.5s forwards';
        
        document.body.appendChild(d);
        setTimeout(() => { if(d.parentNode) d.remove(); }, 1500);
    }

    function updateUI() {
        const pSurCont = document.getElementById('player-sur-container');
        const cSurCont = document.getElementById('cpu-sur-container');
        
        pSurCont.innerHTML = '';
        for(let i=0; i<playerSurs; i++) {
            const sp = document.createElement('div');
            sp.className = 'sur-pill';
            sp.textContent = 'SUR';
            pSurCont.appendChild(sp);
        }

        cSurCont.innerHTML = '';
        for(let i=0; i<cpuSurs; i++) {
            const sp = document.createElement('div');
            sp.className = 'sur-pill';
            sp.textContent = 'SUR';
            cSurCont.appendChild(sp);
        }

        document.getElementById('deck-counter-pill').textContent = `Deck: ${deck.length}`;

        const tableDiv = document.getElementById('table-area');
        // Clear children but avoid removing the pill
        Array.from(tableDiv.children).forEach(child => {
            if (child.id !== 'deck-counter-pill') child.remove();
        });

        table.forEach((card, idx) => {
            const el = createCardEl(card);
            el.onclick = () => toggleTableSelection(idx);
            if (selectedTableIndices.includes(idx)) el.classList.add('target-selected');
            tableDiv.appendChild(el);
        });

        const pHandDiv = document.getElementById('player-hand');
        pHandDiv.innerHTML = '';
        playerHand.forEach((card, idx) => {
            const el = createCardEl(card);
            el.onclick = () => selectHandCard(idx);
            if (idx === selectedHandIndex) el.classList.add('selected');
            pHandDiv.appendChild(el);
        });

        const cHandDiv = document.getElementById('opponent-hand');
        cHandDiv.innerHTML = '';
        cpuHand.forEach(() => {
            const el = document.createElement('div');
            el.className = 'card';
            el.style.background = 'linear-gradient(135deg, #602a2a 0%, #3d0d0d 100%)';
            el.style.border = '2px solid white';
            cHandDiv.appendChild(el);
        });
        
        checkPossibleMoves();
    }

    function createCardEl(card) {
        const el = document.createElement('div');
        el.className = `card ${['♥','♦'].includes(card.suit) ? 'red' : 'black'}`;
        el.innerHTML = `
            <div style="font-size:14px; text-align:left;">${card.rank}</div>
            <div class="card-center">${card.suit}</div>
            <div style="font-size:14px; text-align:right; transform: rotate(180deg);">${card.rank}</div>
        `;
        return el;
    }

    function selectHandCard(idx) {
        if (!isPlayerTurn || isPaused) return;
        if (selectedHandIndex === idx) selectedHandIndex = -1; 
        else selectedHandIndex = idx;
        selectedTableIndices = []; 
        updateUI();
    }

    function toggleTableSelection(idx) {
        if (!isPlayerTurn || isPaused) return;
        if (selectedHandIndex === -1) {
            showToast("Select a card first");
            return; 
        }
        const pos = selectedTableIndices.indexOf(idx);
        if (pos >= 0) selectedTableIndices.splice(pos, 1);
        else selectedTableIndices.push(idx);
        updateUI();
    }

    document.addEventListener('touchstart', e => {
        touchStartY = e.changedTouches[0].screenY;
        touchStartTime = new Date().getTime();
    }, {passive: false});

    document.addEventListener('touchend', e => {
        const touchEndY = e.changedTouches[0].screenY;
        const endTime = new Date().getTime();
        
        const distance = touchStartY - touchEndY; // Positive = UP
        const duration = endTime - touchStartTime;

        if (distance > 150 && duration < 400) {
            location.reload();
        }
    }, {passive: false});

    const styleSheet = document.createElement("style");
    styleSheet.innerText = `
        @keyframes fadeout {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -60%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -100%); }
        }
    `;
    document.head.appendChild(styleSheet);

    initGame();
</script>
</body>
</html>
